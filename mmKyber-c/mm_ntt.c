//  mm_ntt.c
//  === Number Theoretic Trnsforms

#include "mm_ring.h"

//  === Roots of unity constants, multiplied with Montgomery factor R.

static const int32_t mm_w[MM_D] = {
    524160,     6759380,    11611772,   20051184,   5611999,    9265027,
    19493511,   10764447,   24000204,   6177812,    32900457,   32410281,
    23400652,   3198144,    2200199,    24124141,   28206570,   15280732,
    17354707,   12498775,   18285219,   30499698,   12450192,   5644069,
    11930096,   17535208,   32021213,   28870577,   16657861,   32738467,
    28138468,   33049270,   3925647,    22891714,   32084204,   20016426,
    19793647,   9217272,    18447657,   25090164,   17182522,   23808311,
    16908244,   22122426,   17558876,   22883012,   6983968,    24272961,
    875322,     18546326,   6067746,    24580770,   18170667,   10496054,
    15608693,   2515533,    44602,      10865068,   23754885,   12096975,
    16076627,   9986178,    14086122,   2292012,    29787612,   7503285,
    11189900,   31631832,   5860566,    10986757,   28381447,   30095497,
    6958801,    20465111,   274280,     27204547,   1594993,    13111549,
    11767139,   10268342,   14317088,   12984689,   15944111,   30813171,
    2694593,    26451815,   6406585,    20010985,   26966511,   30969403,
    10350944,   17755942,   31244694,   16592269,   15029351,   31275530,
    30598763,   9444158,    4158217,    295408,     1312494,    28869312,
    28382998,   25119048,   21586133,   2174608,    971182,     16930314,
    16089224,   33164555,   25578586,   11520949,   11902971,   25958325,
    25622482,   5788647,    1512189,    23129892,   33548073,   33265110,
    4757561,    33361188,   12394212,   24969419,   29092517,   24807116,
    27320357,   356339,     33073869,   8792503,    17918503,   10321733,
    7192988,    29800114,   26258901,   31299552,   27332300,   32966155,
    12276016,   10730693,   23321992,   12553039,   24560419,   8395453,
    9254376,    7168707,    20172936,   14752366,   28613855,   20608463,
    19639872,   350844,     7143126,    5527986,    31109078,   5790148,
    20006024,   4038243,    23863466,   5400208,    32661754,   7865111,
    22892358,   26801289,   11396388,   5957087,    24061947,   10088648,
    17583519,   17318481,   6137845,    22490456,   28710073,   23987117,
    15764394,   27006783,   17495707,   8448824,    15301221,   7050722,
    21141507,   32554080,   15212341,   26202716,   3544406,    5492562,
    7467341,    15476051,   9331981,    23955081,   22876568,   26738484,
    18765598,   549280,     27900090,   28595224,   9821018,    16583057,
    2391744,    2331434,    32156118,   26379347,   28313524,   16811031,
    10167038,   10798836,   29582106,   15015034,   6681561,    3320266,
    8152825,    28274051,   3493835,    26996082,   7409310,    1126043,
    24105137,   21309313,   1340079,    18429480,   20985077,   33504217,
    25114323,   7283953,    23346277,   1993842,    23696636,   890780,
    11970518,   5882189,    32328326,   6581391,    22682749,   21303665,
    31075518,   5592919,    31118264,   21677573,   14228138,   11292275,
    16675504,   22854030,   1831143,    6911566,    31256330,   23926560,
    29285890,   9587262,    18068068,   16494188,   8860636,    9193484,
    24253081,   11613809,   32254537,   31413463    };

//  Forward NTT (negacyclic -- evaluate polynomial at factors of x^n+1).

void polyr_fntt(int32_t *f)
{
    int i, j, k;
    int32_t x, y, z;
    int32_t *p0, *p1, *p2;

    const int32_t *w = mm_w + 1;

    for (k = 1, j = MM_D >> 1; j > 0; k <<= 1, j >>= 1) {

        p0 = f;
        for (i = 0; i < k; i++) {
            z = *w++;
            p1 = p0 + j;
            p2 = p1 + j;

            while (p1 < p2) {
                x = *p0;
                y = *p1;
                y = mont_mulq(y, z);
                *p0++ = x + y;
                *p1++ = x - y;
            }
            p0 = p2;
        }
    }
}

//  Reverse NTT (negacyclic -- x^n+1), normalize by 1/(n*r).

void polyr_intt(int32_t *f)
{
    int i, j, k;
    int32_t x, y, z;
    int32_t *p0, *p1, *p2;

    const int32_t *w = &mm_w[MM_D - 1];

    for (j = 1, k = MM_D >> 1; k > 0; j <<= 1, k >>= 1) {

        p0 = f;

        for (i = 0; i < k; i++) {
            z = *w--;
            p1 = p0 + j;
            p2 = p1 + j;

            while (p1 < p2) {
                x = *p0;
                y = *p1;
                *p0++ = mont_red1(x + y);
                *p1++ = mont_mulq(y - x, z);
            }
            p0 = p2;
        }
    }

    //  normalization
    for (i = 0; i < MM_D; i++) {
        f[i] = mont_cadd(mont_mulq(f[i], MONT_DI));
    }
}

